# Nginx 살펴보기

> Nginx는 아파치 서버의 한계를 보완하는 용도로 처음 등장했다. 그렇기 때문에 우선 초기 아파치 서버에 대해서 알아보도록 하자

## 초기 아파치 서버

`아파치 HTTP 서버`는 웹 서버 소프트웨어로, 클라이언트의 웹 브라우저로부터 HTTP 요청을 받아 정적 웹 페이지, 동적 웹 페이지, 이미지, 스크립트, 스타일 시트 등의 웹 콘텐츠를 제공하는 역할을 한다.

클라이언트의 요청이 아파치 서버로 들어오면 `아파치는 클라이언트와의 커넥션을 형성하기 위해 별도의 프로세스 또는 쓰레드를 생성`합한다. 하지만 매번 새로운 프로세스를 생성하는 것은 오버헤드를 발생시키기 떄문에 Prefork 방식을 채택하여 부담을 감소시킨다. Prefork는 사전에 프로세스를 생성해 둔 뒤 필요에 따라 배정하는 방식이라 볼 수 있다.

아파치 서버는 모듈 확장성과 유연성에 유리한 모듈 아키텍처가 적용되어 있다. 그렇기 때문에 서버스의 요구사항에 따른 내부 기능을 추가하는 것이 비교적 쉬운 구조이므로 많은 인기를 받았다고 한다. 그 덕분에 자연스럽게 하나의 서버 내부에서 지속적으로 다양한 기능이 추가되고, 점점 쌓여가는 모놀리식(monolithic) 아키텍처로 서버를 구성하게 되었다. 이는 현재의 MSA(Micro Service Architecture)와 비교했을 때 서버 구성이 단순하므로 유지 보수에 용이하기도 하다.

## 아파치 서버의 문제점

PC(Personal Computer) 보급의 증가와 가정용 인터넷의 도입으로 인해 클라이언트의 수가 점점 증가하기 시작하면서 문제점이 드러나기 시작했다. 그 이유는 클라이언트의 증가는 곧 트래픽의 증가를 뜻하기 때문이다.

아파치 서버는 클라이언트와의 커넥션을 형성할 때 별도의 프로세스를 배정한다고 했다. 그러므로 클라이언트가 증가하면 커넥션이 덩달아 증가하고, 프로세스도 그만큼 증가함을 의미한다. 프로세스의 생성은 메모리 할당으로 이루어지고, 그 수가 증가한다면 당연히 메모리 부족이 발생하게 된다. 즉 트래픽이 증가할수록 메모리 부담이 커지는 것이고, 이는 종종 서버를 다운시켜 버렸다.

이 뿐만이 아니다. 프로세스를 처리하는 것은 CPU의 역할인데, 프로세스가 증가했으니 CPU가 얼마나 바쁘겠는가? 그러므로 CPU 과부하가 발생한다. CPU는 효율적으로 일하기 위해 선점/비선점 방식을 혼합해서 프로세스를 처리했을 것으로 예상되는데, 선점 방식의 경우 그 많은 프로세스의 우선순위를 매기기 위해 Context Switching이 얼마나 자주, 많이 발생했을지 상상해보자.

`C10K` 라는 문제가 이때 나타나기 시작했다. 이는 10k(10,000)개의 커넥션이 형성되면 이후 커넥션 형성에 문제가 발생함을 뜻하는 용어이다. 컴퓨팅 리소스를 향상시키는 Scale-up 방식을 채택하여 문제를 해결할 수도 있겠지만 이후 `스마트폰의 등장이 트래픽을 비약적으로 향상시키게 된다`는 점을 생각하면 근본적인 대책이 필요했을 것이다.

## Nginx의 등장

Nginx는 Event-driven server로 구성되어 이벤트 기반으로 요청과 커넥션 형성을 처리한다. 마스터 프로세스가 워커 프로세스를 관리하고, 워커 프로세스는 커넥션의 형성과 요청 처리, 종료 작업을 커널 OS에서 전해주는 Queue로 요청 작업 리스트를 받아 비동기적으로 처리한다. 즉 하나의 커넥션이 하나의 프로세스와 소통하는 아파치의 방식과 달리 하나의 프로세스가 여러 요청을 처리하는 구조인 것이다. 그러므로 프로세스 생성이 아파치만큼 발생할 필요가 없는 것이다.

이러한 방식이 가능한 이유는 클라이언트와 프로세스간 요청이 들어오는 것, 커넥션을 형성하는 것, 요청을 완료하면 커넥션을 종료하는 것 모두 이벤트로 등록되어 소켓 통신을 통해 실시간으로 처리하기 때문이다. 여러 요청이 Queue에 의해 줄세워 지고, 하나의 프로세스가 이를 순차 처리하므로 효율성을 극대화할 수 있는 방식인 것이다.

게다가 프로세스 내 멀티 스레딩으로 요청을 처리하는데, 이는 내부적으로 CPU Burst가 높은 요청의 경우 다른 스레드로 돌려 따로 처리하도록 하여 블로킹을 최소하므로 이 또한 응답 속도를 높이는 주요 역할을 한다.

처음에는 아파치의 입지가 절대적인 수준이었기 때문에 Nginx를 아파치 HTTP 서버의 앞단에 배치시켜 혼용해서 사용하며 트래픽 문제를 해결하는 용도로 사용했다고 한다.

## 아파치는 그래서 몰락인가?

Nginx에도 엄연히 단점이 있다. 바로 기능 추가를 위한 모듈 확장이 어렵다는 점이다. 왜냐하면 모듈 아키텍처로 설계된 아파치 웹 서버는 정적으로 빌드되고 컴파일 된 후에도 동적으로 모듈 로딩/언로딩이 가능하므로 모듈의 확장이 가능하지만 Nginx의 경우 성능 최적화에 중점을 두고 설계되었는데, 이 최적화를 위해 동적으로 모듈 확장을 기본적으로 허용하지 않는 방식을 채택한 것이다. 서버가 컴파일 된 시점에서 모듈의 유동성이 없이야 최적화가 가능하기 떄문이다.

또한 Nginx의 역사가 아파치보다 길지 않은 만큼 가장 중요한 코어 모듈을 제외한다면 추가적인 모듈의 종류가 많지 않다는 점도 하나의 단점이 될 수 있다고 생각한다.

조사에 따르면 Nginx 환경에서 동적 모듈 추가가 불가능한 것은 아니지만 아파치 서버 구조와 비교했을 때 최적화를 위해 복잡한 구조로 동작한다는 것은 확실하므로 서버 내부의 상호작용을 잘 이해하지 못한다면 모듈 추가 과정에서 프로세스가 종료되는 상황이 발생할 것이다.

그러므로 만약 서비스 규모 자체가 대용량 트래픽을 맞이할 정도로 대규모가 아닐 것으로 보인다면 아파치 서버를 채택하는 것이 서비스 확장, 유지 보수 측면에서 유리할 수 있다.

## Nginx의 동적 설정

런타임 서버를 꺼버리고 서버의 내부 설정을 변경한 뒤 다시 빌드를 할 수도 있을 것이다. 하지만 그럴 수 없는 환경이라면 기존에 사용되는 워커 프로세스만큼 신규 프로세스를 생성하여 신규 프로세스에서 설정 변경을 적용 후 요청을 이전하는 방식으로 문제를 해결할 수 있겠다.

## 현재의 Nginx 활용 및 역할

가장 대표적으로 `SSL Termination`, `Caching`, `Load Balancer`의 역할이 있다.

SSL Termination: 서버와 클라이언트 사이에 Nginx 서버를 두고서 Nginx 서버를 중개자 역할로 사용한다면 클라이언트는 Nginx 서버와 https로 통신하고, Nginx 서버와 백엔드 서버는 http로 통신하게 할 수 있을 것이다. 이 경우 Nginx는 리버스 프록시라고 한다. 백엔드 서버가 Nginx 서버에 의해 뒷단으로 감춰져 백엔드 서버가 클라이언트에게 노출되지 않으므로 Nginx가 백엔드 서버와 https 프로토콜로 통신할 필요가 딱히 없으므로 http 프로토콜로 통신하면 되고, 이는 요청 응답에 대한 암호화 과정이 없음을 의미하므로 결론적으로 서버의 부담이 덜어지게 되는 것이다.

Caching: 클라이언트가 자주 요청하는 응답 데이터를 Nginx 서버에 저장해두면 백엔드 서버까지 갈 필요가 없어진다. 이 부분에서 캐시 데이터의 최신화, 동기화가 중요하겠지만 이 부분에서 큰 문제가 발생하지 않는다면 백엔드 서버가 할 일을 덜게 된다. 즉 부담이 덜어진다.

Load Balancer: 로드밸런서 라는 역할을 Nginx 서버에게 맡기는 것이다. 이 역할 역시 Nginx의 리버스 프록시에 해당하는 것으로 클라이언트는 오직 Nginx 서버와만 소통하고, 뒷단에는 동일한 서버를 여러 대 두어 요청을 여러 서버로 분산시키는 역할을 하는 것이다. 가령 세 번의 요청이 들어왔고, 동일한 백엔드 서버가 뒷단에 총 세 대가 존재한다면 각 요청을 각각의 서버에 하나씩 보내는 것이다. 하나의 서버가 세 번의 요청을 처리하는게 아닌 한 번의 요청을 처리하면 되므로 부담이 덜게 된다.
